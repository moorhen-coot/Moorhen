diff --git a/api/coot-molecule-maps.cc b/api/coot-molecule-maps.cc
index 30d59ba28..eb3abc2d3 100644
--- a/api/coot-molecule-maps.cc
+++ b/api/coot-molecule-maps.cc
@@ -259,6 +259,7 @@ coot::molecule_t::update_map_triangles(float radius, coot::Cartesian centre, flo
    if (!xmap.is_null()) {
 
       clear_draw_vecs();
+#ifdef HAVE_CXX_THREAD
       std::vector<std::thread> threads;
       int n_reams = coot::get_max_number_of_threads() - 1;
       if (n_reams < 1) n_reams = 1;
@@ -285,6 +286,18 @@ coot::molecule_t::update_map_triangles(float radius, coot::Cartesian centre, flo
             threads[ii].join();
 
       }
+#else
+      // Single-threaded fallback: call directly with n_reams=1
+      gensurf_and_add_vecs_threaded_workpackage(&xmap, contour_level, dy_radius, centre,
+                                                isample_step, 0, 1, is_em_map,
+                                                &draw_vector_sets);
+      if (xmap_is_diff_map) {
+         clear_diff_map_draw_vecs();
+         gensurf_and_add_vecs_threaded_workpackage(&xmap, -contour_level, dy_radius, centre,
+                                                   isample_step, 0, 1, is_em_map,
+                                                   &draw_diff_map_vector_sets);
+      }
+#endif
 
       if (is_dynamically_transformed_map_flag) {
          for (unsigned int ii=0; ii<draw_vector_sets.size(); ii++) {
diff --git a/api/coot-molecule-refine.cc b/api/coot-molecule-refine.cc
index 611a7842d..c087a3db1 100644
--- a/api/coot-molecule-refine.cc
+++ b/api/coot-molecule-refine.cc
@@ -407,9 +407,11 @@ coot::molecule_t::minimize(const std::string &atom_selection_cid,
       if (do_torsion_restraints) flags = TYPICAL_RESTRAINTS_WITH_TORSIONS;
       pseudo_restraint_bond_type pseudos = NO_PSEUDO_BONDS;
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
       int n_threads = 4; // coot::get_max_number_of_threads();
       ctpl::thread_pool thread_pool(n_threads);
       restraints.thread_pool(&thread_pool, n_threads);
+#endif
 
       int imol = imol_no;
       bool do_auto_helix_restraints = true;
diff --git a/api/coot-molecule-validation.cc b/api/coot-molecule-validation.cc
index 08e580d37..270d64953 100644
--- a/api/coot-molecule-validation.cc
+++ b/api/coot-molecule-validation.cc
@@ -396,9 +396,11 @@ coot::molecule_t::geometric_distortions_from_mol(const atom_selection_container_
                   if (with_nbcs)
                      flags = coot::BONDS_ANGLES_PLANES_NON_BONDED_AND_CHIRALS;
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
                   unsigned int n_threads = coot::get_max_number_of_threads();
                   if (n_threads > 0)
                      restraints.thread_pool(&static_thread_pool, n_threads);
+#endif
                   short int do_residue_internal_torsions = 0;
 
                   //                if (do_torsion_restraints) {
@@ -580,9 +582,11 @@ coot::molecule_t::simple_geometric_distortions_from_mol(const std::string &ligan
                         if (with_nbcs)
                            flags = coot::BONDS_ANGLES_PLANES_NON_BONDED_AND_CHIRALS;
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
                         unsigned int n_threads = coot::get_max_number_of_threads();
                         if (n_threads > 0)
                            restraints.thread_pool(&static_thread_pool, n_threads);
+#endif
                         short int do_residue_internal_torsions = 0;
 
                         //                if (do_torsion_restraints) {
diff --git a/api/coot-molecule.cc b/api/coot-molecule.cc
index 79510c9cf..6a0a22d48 100644
--- a/api/coot-molecule.cc
+++ b/api/coot-molecule.cc
@@ -2627,8 +2627,10 @@ coot::molecule_t::refine_direct(std::vector<mmdb::Residue *> rv, const std::stri
    pseudo_restraint_bond_type pseudos = NO_PSEUDO_BONDS;
 
    int n_threads = max_number_of_threads;
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    ctpl::thread_pool thread_pool(n_threads);
    restraints.thread_pool(&thread_pool, n_threads);
+#endif
 
    int imol = imol_no;
    bool do_auto_helix_restraints = true;
@@ -4503,8 +4505,10 @@ coot::molecule_t::init_all_molecule_refinement(int imol_ref_mol, coot::protein_g
    flags = coot::TYPICAL_RESTRAINTS;
    coot::pseudo_restraint_bond_type pseudos = coot::NO_PSEUDO_BONDS;
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    unsigned int n_threads = 8;
    last_restraints->thread_pool(thread_pool, n_threads);
+#endif
 
    // user-defined LIG diction ahve been assigned to imol_ref_mol, not this one (this one
    // is a temporary molecule used only for refinement).
diff --git a/api/molecules-container-maps.cc b/api/molecules-container-maps.cc
index 03398d50d..836d8fdf6 100644
--- a/api/molecules-container-maps.cc
+++ b/api/molecules-container-maps.cc
@@ -723,8 +723,13 @@ molecules_container_t::get_map_vertices_histogram(int imol, int imol_map_for_sam
       if (is_valid_map_molecule(imol_map_for_sampling)) {
 	 clipper::Coord_orth p(position_x, position_y, position_z);
 	 const clipper::Xmap<float> &other_xmap = molecules[imol_map_for_sampling].xmap;
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 	 hi = molecules[imol].get_map_vertices_histogram(other_xmap, p, radius, contour_level,
 							 map_is_contoured_using_thread_pool_flag, &thread_pool, n_bins);
+#else
+	 hi = molecules[imol].get_map_vertices_histogram(other_xmap, p, radius, contour_level,
+							 false, nullptr, n_bins);
+#endif
       }
    }
    return hi;
diff --git a/api/molecules-container.cc b/api/molecules-container.cc
index 6de073bc3..ad4e2c711 100644
--- a/api/molecules-container.cc
+++ b/api/molecules-container.cc
@@ -66,7 +66,8 @@ molecules_container_t::~molecules_container_t() {
 // verbose is an optional arg, default true
 molecules_container_t::molecules_container_t(bool verbose) :
    ramachandrans_container(ramachandrans_container_t()),
-   thread_pool(8) {
+   thread_pool(8)  // Uses stub implementation when threading disabled
+{
    if (! verbose) geom.set_verbose(false);
    init();
 }
@@ -2174,7 +2175,11 @@ molecules_container_t::get_map_contours_mesh(int imol, double position_x, double
             update_updating_maps(updating_maps_info.imol_model);
          }
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
          mesh = molecules[imol].get_map_contours_mesh(position, radius, contour_level, map_is_contoured_using_thread_pool_flag, &thread_pool);
+#else
+         mesh = molecules[imol].get_map_contours_mesh(position, radius, contour_level, false, nullptr);
+#endif
       } else {
          std::cout << "WARNING:: get_map_contours_mesh() Not a valid map molecule " << imol << std::endl;
       }
@@ -2954,7 +2959,11 @@ molecules_container_t::refine_direct(int imol, std::vector<mmdb::Residue *> rv,
                 << std::endl;
 
    // this is not stored in molecules_container!
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    unsigned int max_number_of_threads = thread_pool.size();
+#else
+   unsigned int max_number_of_threads = 1;
+#endif
 
    int status = 0;
    if (is_valid_model_molecule(imol)) {
@@ -3648,9 +3657,11 @@ molecules_container_t::make_last_restraints(const std::vector<std::pair<bool,mmd
    if (use_map_flag)
       last_restraints->add_map(geometry_vs_map_weight);
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    unsigned int n_threads = coot::get_max_number_of_threads();
    if (n_threads > 0)
       last_restraints->thread_pool(&thread_pool, n_threads);
+#endif
 
    all_atom_pulls_off();
    particles_have_been_shown_already_for_this_round_flag = false;
@@ -5549,7 +5560,9 @@ molecules_container_t::get_hb_type(const std::string &compound_id, int imol_enc,
 void
 molecules_container_t::set_max_number_of_threads(unsigned int n_threads) {
    coot::set_max_number_of_threads(n_threads);
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    thread_pool.resize(n_threads);
+#endif
 }
 
 // call the above function
@@ -5617,6 +5630,7 @@ molecules_container_t::test_launching_threads(unsigned int n_threads_per_batch,
 double
 molecules_container_t::test_thread_pool_threads(unsigned int n_threads) {
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    auto sum = [] (unsigned int thread_index, unsigned int i, unsigned int j, std::atomic<unsigned int> &done_count_for_threads) {
       done_count_for_threads++;
       return i+j;
@@ -5636,6 +5650,9 @@ molecules_container_t::test_thread_pool_threads(unsigned int n_threads) {
    auto d10 = std::chrono::duration_cast<std::chrono::microseconds>(tp_1 - tp_0).count();
    t = d10;
    return t;
+#else
+   return 0.0;
+#endif
 
 }
 
diff --git a/api/molecules-container.hh b/api/molecules-container.hh
index 5e5685ce0..825b97531 100644
--- a/api/molecules-container.hh
+++ b/api/molecules-container.hh
@@ -144,7 +144,7 @@ class molecules_container_t {
    bool use_torsion_restraints;
    float torsion_restraints_weight;
 
-   ctpl::thread_pool thread_pool;
+   ctpl::thread_pool thread_pool;  // Uses stub implementation when threading disabled
    bool show_timings;
 
    coot::restraints_container_t *last_restraints;
diff --git a/coot-utils/atom-overlaps.cc b/coot-utils/atom-overlaps.cc
index 7ed48dc56..bf5da401e 100644
--- a/coot-utils/atom-overlaps.cc
+++ b/coot-utils/atom-overlaps.cc
@@ -1878,7 +1878,9 @@ coot::atom_overlaps_container_t::all_atom_contact_dots_internal_multi_thread(dou
 
          unsigned int n_threads = get_max_number_of_threads();
          n_threads = 1;
+#ifdef HAVE_CXX_THREAD
          std::vector<std::thread> threads;
+#endif
          unsigned int n_per_thread = n_selected_atoms/n_threads;
          // std::cout << "n per thread " << n_per_thread << std::endl;
          std::vector<atom_overlaps_dots_container_t> results_container_vec(n_threads);
@@ -1898,17 +1900,29 @@ coot::atom_overlaps_container_t::all_atom_contact_dots_internal_multi_thread(dou
             // 20230814-PE I saw a crash here today. It seems to be crashing on the creation
             // of the thread - I don't know what that means.
             //
+#ifdef HAVE_CXX_THREAD
             threads.push_back(std::thread(contacts_for_atoms, iat_start, iat_end,
                                           atom_selection, contact_map, bonded_map,
                                           neighb_atom_radius, udd_h_bond_type_handle,
                                           molecule_has_hydrogens, probe_radius,
                                           dot_density_in, clash_spike_length, make_vdw_surface,
                                           &results_container_vec[i_thread]));
+#else
+            // Single-threaded: call directly
+            contacts_for_atoms(iat_start, iat_end,
+                              atom_selection, contact_map, bonded_map,
+                              neighb_atom_radius, udd_h_bond_type_handle,
+                              molecule_has_hydrogens, probe_radius,
+                              dot_density_in, clash_spike_length, make_vdw_surface,
+                              &results_container_vec[i_thread]);
+#endif
 
          }
 
+#ifdef HAVE_CXX_THREAD
          for (unsigned int i_thread=0; i_thread<n_threads; i_thread++)
             threads.at(i_thread).join();
+#endif
 
          if (false) {
             for (unsigned int i_thread=0; i_thread<n_threads; i_thread++) {
diff --git a/coot-utils/slurp-map.cc b/coot-utils/slurp-map.cc
index 7025c6fbd..b41a53062 100644
--- a/coot-utils/slurp-map.cc
+++ b/coot-utils/slurp-map.cc
@@ -414,6 +414,7 @@ coot::util::slurp_parse_xmap_data(char *data,
                unsigned int grid_offset = c_u * gs.nu() * gs.nv() + c_v * gs.nv() + c_w;
                const float f = *reinterpret_cast<const float *>(map_data + 4 * offset + 4 * grid_offset);
 
+#ifdef HAVE_CXX_THREAD
                if (true) { // debugging
                   bool unlocked = false;
                   while (! print_lock.compare_exchange_weak(unlocked, true)) {
@@ -423,6 +424,7 @@ coot::util::slurp_parse_xmap_data(char *data,
                   std::cout << " " << iw.coord().format() << " " << f << std::endl;
                   print_lock = false;
                }
+#endif
 
                (*xmap)[iw] = f;
                c_w++;
@@ -448,6 +450,7 @@ coot::util::slurp_parse_xmap_data(char *data,
                                clipper::Xmap<float>::Map_reference_coord mrc(*xmap);
                                // this is unsigned int because split_indices returns unsigned int pairs.
 
+#ifdef HAVE_CXX_THREAD
                                if (false) { // debugging
                                   bool unlocked = false;
                                   while (! print_lock.compare_exchange_weak(unlocked, true)) {
@@ -460,6 +463,7 @@ coot::util::slurp_parse_xmap_data(char *data,
                                             << std::endl;
                                   print_lock = false;
                                }
+#endif
 
                                for (unsigned int isec = start_stop_section_index.first; isec < start_stop_section_index.second; isec++ ) {
 
@@ -487,6 +491,7 @@ coot::util::slurp_parse_xmap_data(char *data,
                                   }
                                }
 
+#ifdef HAVE_CXX_THREAD
                                if (false) { // debugging
                                   bool unlocked = false;
                                   while (! print_lock.compare_exchange_weak(unlocked, true)) {
@@ -497,6 +502,7 @@ coot::util::slurp_parse_xmap_data(char *data,
                                             << start_stop_section_index.second << "\n";
                                   print_lock = false;
                                }
+#endif
                             };
 
 
diff --git a/ideal/chirals.cc b/ideal/chirals.cc
index bd3d8429e..196052a55 100644
--- a/ideal/chirals.cc
+++ b/ideal/chirals.cc
@@ -766,9 +766,11 @@ coot::distorted_chiral_volumes(int imol, mmdb::Manager *mol, protein_geometry *g
    bool do_link_restraints = false;
    bool do_flank_restraints = false;
    pseudo_restraint_bond_type pseudos = coot::NO_PSEUDO_BONDS;
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    int n_threads = 1;
    ctpl::thread_pool tp(n_threads);
    restraints.thread_pool(&tp, n_threads);
+#endif
 
    // this is making nbc restraints I think - stop it.
    int n_restraints = restraints.make_restraints(imol, *geom_p, flags, 1, do_trans_peptide_restraints,
diff --git a/ideal/crankshaft.cc b/ideal/crankshaft.cc
index 10fa8f8f8..762faf084 100644
--- a/ideal/crankshaft.cc
+++ b/ideal/crankshaft.cc
@@ -1572,7 +1572,9 @@ coot::crankshaft::refine_and_score_mol(mmdb::Manager *mol,
       auto tp_0 = std::chrono::high_resolution_clock::now();
 
       restraints_container_t restraints(refine_residues, links, geom, mol, fixed_atom_specs, &xmap);
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
       restraints.thread_pool(thread_pool_p, n_threads_in);
+#endif
       restraints.set_quiet_reporting();
       restraints.add_map(map_weight);
       restraints.set_rama_type(restraints_rama_type);
diff --git a/ideal/make-restraints.cc b/ideal/make-restraints.cc
index c15a6edea..0925177be 100644
--- a/ideal/make-restraints.cc
+++ b/ideal/make-restraints.cc
@@ -78,7 +78,7 @@ coot::restraints_container_t::make_restraints(int imol,
 					      bool do_flank_restraints) {
 
 
-#if 1
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 
    make_restraints_ng(imol, geom, flags_in, do_residue_internal_torsions, do_trans_peptide_restraints,
 		      rama_plot_target_weight, do_rama_plot_restraints,
@@ -88,7 +88,7 @@ coot::restraints_container_t::make_restraints(int imol,
 		      sec_struct_pseudo_bonds, do_link_restraints, do_flank_restraints);
 
    return size();
-#endif
+#endif // HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 
    // if a peptide is trans, add a restraint to penalize non-trans configuration
    // (currently a torsion restraint on peptide w of 180)
diff --git a/ideal/model-bond-deltas.cc b/ideal/model-bond-deltas.cc
index 5f47f825d..7fc3790f8 100644
--- a/ideal/model-bond-deltas.cc
+++ b/ideal/model-bond-deltas.cc
@@ -98,9 +98,11 @@ coot::model_bond_deltas::resolve() {
 
 	 restraints_container_t restraints(residues, *geom_p, mol, &dummy_xmap);
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 	 int n_threads = 2;
 	 ctpl::thread_pool thread_pool(n_threads);
 	 restraints.thread_pool(&thread_pool, n_threads);
+#endif
 
 	 restraint_usage_Flags flags = coot::BONDS;
 	 pseudo_restraint_bond_type pseudos = coot::NO_PSEUDO_BONDS;
diff --git a/ideal/ng.cc b/ideal/ng.cc
index 724e39d3b..1ed4cc115 100644
--- a/ideal/ng.cc
+++ b/ideal/ng.cc
@@ -27,17 +27,17 @@
 #include <iomanip>
 
 #include "compat/coot-sysdep.h"
+#include "simple-restraint.hh"
 
 #include "coot-utils/bonded-pairs.hh"
 #include "geometry/residue-and-atom-specs.hh"
-#include "simple-restraint.hh"
 #include "coot-utils/contacts-by-bricks.hh"
 #include "coot-utils/stack-and-pair.hh"
 
 #include "utils/logging.hh"
 extern logging logger;
 
-
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 int
 coot::restraints_container_t::make_restraints_ng(int imol,
                                                  const coot::protein_geometry &geom,
@@ -212,6 +212,7 @@ coot::restraints_container_t::make_restraints_ng(int imol,
       restraints_vec[i].restraint_index = i;
    return size();
 }
+#endif // HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 
 
 void
@@ -540,6 +541,7 @@ coot::restraints_container_t::make_flanking_atoms_restraints_ng(const coot::prot
    // flank_restraints.report();
 }
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 // static
 void
 coot::restraints_container_t::make_non_bonded_contact_restraints_workpackage_ng(int ithread,
@@ -1139,6 +1141,7 @@ coot::restraints_container_t::make_non_bonded_contact_restraints_using_threads_n
                 << " adding NBCs to restraints " << d65 << std::endl;
 
 }
+#endif // HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
 
 
 unsigned int
@@ -1461,9 +1464,11 @@ coot::restraints_container_t::make_non_bonded_contact_restraints_ng(int imol,
       }
    }
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    make_df_restraints_indices();
    // is the following needed? I doubt.
    make_distortion_electron_density_ranges();
+#endif
 
    return n_nbc_restraints;
 
diff --git a/ideal/regularize-minimol.cc b/ideal/regularize-minimol.cc
index b265a3771..e6ee3d345 100644
--- a/ideal/regularize-minimol.cc
+++ b/ideal/regularize-minimol.cc
@@ -89,10 +89,14 @@ coot::refine_minimol_fragment(coot::minimol::fragment &frag,
    }
 
    if (! residues.empty()) {
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
       int n_threads = 1; // needs optimizing
       ctpl::thread_pool tp(n_threads);
+#endif
       coot::restraints_container_t restraints(residues, geom, mol, &xmap);
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
       restraints.thread_pool(&tp, n_threads);
+#endif
 
       coot::restraint_usage_Flags flags = coot::TYPICAL_RESTRAINTS; // include GM
       bool do_residue_internal_torsions = false;
@@ -166,6 +170,7 @@ coot::regularize_minimol_molecule(const coot::minimol::molecule &molin,
       coot::restraints_container_t restraints(residues, geom, mol, &dummy_xmap);
       restraints.set_quiet_reporting();
 
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
       int n_threads_max = get_max_number_of_threads();
       int n_threads = n_threads_max -1;
       if (n_threads < 1) n_threads = 1;
@@ -177,6 +182,7 @@ coot::regularize_minimol_molecule(const coot::minimol::molecule &molin,
       ctpl::thread_pool tp(n_threads);
       // std::cout << "set thread pool " << n_threads << std::endl;
       restraints.thread_pool(&tp, n_threads);
+#endif
 
       coot::restraint_usage_Flags flags = coot::BONDS_ANGLES_TORSIONS_NON_BONDED_CHIRALS_AND_PLANES;
       bool do_residue_internal_torsions = false;
diff --git a/ideal/simple-restraint.cc b/ideal/simple-restraint.cc
index 926ee9f21..f55cf9aec 100644
--- a/ideal/simple-restraint.cc
+++ b/ideal/simple-restraint.cc
@@ -4919,9 +4919,11 @@ coot::simple_refine(mmdb::Residue *residue_p,
 	 pseudo_restraint_bond_type pseudos = coot::NO_PSEUDO_BONDS;
 	 bool do_internal_torsions = true;
 	 bool do_trans_peptide_restraints = true;
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
          int n_threads = coot::get_max_number_of_threads();
          ctpl::thread_pool thread_pool(n_threads);
          restraints.thread_pool(&thread_pool, n_threads);
+#endif
 	 restraints.make_restraints(imol, geom, flags, do_internal_torsions,
 				    do_trans_peptide_restraints, 0, 0, true, true, false, pseudos);
 
diff --git a/ligand/multi-peptide.cc b/ligand/multi-peptide.cc
index 62e2c1d97..5aa275cc5 100644
--- a/ligand/multi-peptide.cc
+++ b/ligand/multi-peptide.cc
@@ -1429,6 +1429,7 @@ coot::multi_build_terminal_residue_addition::refine_end(coot::minimol::fragment
       }
    }
    restraints_container_t restraints(residues, links, geom, mol, fixed_atom_specs, &xmap);
+#ifdef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
    restraints.thread_pool(thread_pool_p, n_threads);
 
    // Does this make things slower? (seems so, try passing the thread pool
@@ -1436,6 +1437,7 @@ coot::multi_build_terminal_residue_addition::refine_end(coot::minimol::fragment
    //
    ctpl::thread_pool thread_pool(coot::get_max_number_of_threads());
    restraints.thread_pool(&thread_pool, get_max_number_of_threads());
+#endif
 
    pseudo_restraint_bond_type pseudos = NO_PSEUDO_BONDS;
    bool do_internal_torsions = false;
diff --git a/utils/ctpl.h b/utils/ctpl.h
index 4ade8e1a0..ec8d50d24 100644
--- a/utils/ctpl.h
+++ b/utils/ctpl.h
@@ -21,6 +21,13 @@
 #ifndef __ctpl_thread_pool_H__
 #define __ctpl_thread_pool_H__
 
+// When HAVE_BOOST_BASED_THREAD_POOL_LIBRARY is not defined, use stub implementation
+#ifndef HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
+
+#include "ctpl_stub.h"
+
+#else // HAVE_BOOST_BASED_THREAD_POOL_LIBRARY is defined - use full threaded implementation
+
 #include <functional>
 #include <thread>
 #include <atomic>
@@ -236,5 +243,7 @@ namespace ctpl {
 
 }
 
+#endif // HAVE_BOOST_BASED_THREAD_POOL_LIBRARY
+
 #endif // __ctpl_thread_pool_H__
 

diff --git a/utils/ctpl_stub.h b/utils/ctpl_stub.h
new file mode 100644
--- /dev/null
+++ b/utils/ctpl_stub.h
@@ -0,0 +1,      93 @@
+
+/*********************************************************
+ *
+ *  Stub thread pool for single-threaded builds.
+ *  Provides the same interface as ctpl::thread_pool but
+ *  executes all tasks synchronously on the calling thread.
+ *
+ *********************************************************/
+
+#ifndef __ctpl_stub_thread_pool_H__
+#define __ctpl_stub_thread_pool_H__
+
+#include <functional>
+#include <future>
+#include <memory>
+
+namespace ctpl {
+
+    // Stub thread_pool that executes tasks synchronously
+    // Used when HAVE_BOOST_BASED_THREAD_POOL_LIBRARY is not defined
+    class thread_pool {
+
+    public:
+
+        thread_pool() {}
+        thread_pool(int nThreads, int queueSize = 100) {
+            // Ignore thread count - we execute everything synchronously
+            (void)nThreads;
+            (void)queueSize;
+        }
+
+        ~thread_pool() {}
+
+        // Always report 1 "thread" (the main thread)
+        int size() { return 1; }
+
+        // No idle threads in stub
+        int n_idle() { return 0; }
+
+        // Change thread count - no-op in stub
+        void resize(int nThreads) {
+            (void)nThreads;
+        }
+
+        // Clear queue - no-op since we execute immediately
+        void clear_queue() {}
+
+        // Pop - returns empty function since queue is always empty
+        std::function<void(int)> pop() {
+            return std::function<void(int)>();
+        }
+
+        // Stop - no-op in stub
+        void stop(bool isWait = false) {
+            (void)isWait;
+        }
+
+        // Push with additional arguments - execute synchronously and return future
+        template<typename F, typename... Rest>
+        auto push(F && f, Rest&&... rest) -> std::future<decltype(f(0, rest...))> {
+            // Create a packaged task
+            auto pck = std::make_shared<std::packaged_task<decltype(f(0, rest...))(int)>>(
+                std::bind(std::forward<F>(f), std::placeholders::_1, std::forward<Rest>(rest)...)
+            );
+
+            // Execute immediately with thread id 0
+            (*pck)(0);
+
+            return pck->get_future();
+        }
+
+        // Push simple function - execute synchronously and return future
+        template<typename F>
+        auto push(F && f) -> std::future<decltype(f(0))> {
+            auto pck = std::make_shared<std::packaged_task<decltype(f(0))(int)>>(std::forward<F>(f));
+
+            // Execute immediately with thread id 0
+            (*pck)(0);
+
+            return pck->get_future();
+        }
+
+    private:
+        // Deleted copy/move constructors and assignment operators
+        thread_pool(const thread_pool &) = delete;
+        thread_pool(thread_pool &&) = delete;
+        thread_pool & operator=(const thread_pool &) = delete;
+        thread_pool & operator=(thread_pool &&) = delete;
+    };
+
+}
+
+#endif // __ctpl_stub_thread_pool_H__
