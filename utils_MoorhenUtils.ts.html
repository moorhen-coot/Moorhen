

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> utils/MoorhenUtils.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="docs.styles.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
             
                <a class="image" href="index.html">
                    <img src="./MoorhenLogo.png" alt="logo">
                </a>
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Moorhen Developer Documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/moorhen-coot/Moorhen"
                        >
                            Github
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://moorhen-coot.github.io/wiki/"
                        >
                            Moorhen Wiki
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="MoorhenCommandCentre.html">MoorhenCommandCentre</a></li><li><a href="MoorhenMap.html">MoorhenMap</a></li><li><a href="MoorhenMolecule.html">MoorhenMolecule</a></li><li><a href="MoorhenPreferences.html">MoorhenPreferences</a></li><li><a href="MoorhenTimeCapsule.html">MoorhenTimeCapsule</a></li></ul><h3>Global</h3><ul><li><a href="global.html#MoorhenContainer">MoorhenContainer</a></li><li><a href="global.html#MoorhenDraggableModalBase">MoorhenDraggableModalBase</a></li><li><a href="global.html#MoorhenMapSelect">MoorhenMapSelect</a></li><li><a href="global.html#MoorhenMoleculeSelect">MoorhenMoleculeSelect</a></li><li><a href="global.html#loadSessionData">loadSessionData</a></li><li><a href="global.html#loadSessionFromJsonString">loadSessionFromJsonString</a></li><li><a href="global.html#loadSessionFromProtoMessage">loadSessionFromProtoMessage</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>utils/MoorhenUtils.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { hexToRgb } from "@mui/material";
import localforage from 'localforage';
import * as vec3 from 'gl-matrix/vec3';
import * as mat3 from 'gl-matrix/mat3';
import { MoorhenMolecule } from "./MoorhenMolecule";
import { MoorhenMap } from "./MoorhenMap";
import { MoorhenColourRule } from "./MoorhenColourRule";
import { moorhen } from "../types/moorhen";
import { gemmi } from "../types/gemmi";
import { webGL } from "../types/mgWebGL";
import { AnyAction, Dispatch } from "@reduxjs/toolkit";
import { addCustomRepresentation, addMolecule, emptyMolecules } from "../store/moleculesSlice";
import { addMap, emptyMaps } from "../store/mapsSlice";
import { batch } from "react-redux";
import { setActiveMap } from "../store/generalStatesSlice";
import { setContourLevel, setMapAlpha, setMapColours, setMapRadius, setMapStyle, setNegativeMapColours, setPositiveMapColours } from "../store/mapContourSettingsSlice";
import { enableUpdatingMaps, setConnectedMoleculeMolNo, setFoFcMapMolNo, setReflectionMapMolNo, setTwoFoFcMapMolNo } from "../store/moleculeMapUpdateSlice";
import { libcootApi } from "../types/libcoot";
import { 
    setBackgroundColor, setDepthBlurDepth, setDepthBlurRadius, setDoEdgeDetect, setDoSSAO, setDoShadow, 
    setEdgeDetectDepthScale, setEdgeDetectDepthThreshold, setEdgeDetectNormalScale, setEdgeDetectNormalThreshold, setSsaoBias, setSsaoRadius, setUseOffScreenBuffers 
} from "../store/sceneSettingsSlice";
import { moorhensession } from "../protobuf/MoorhenSession";
import { ToolkitStore } from "@reduxjs/toolkit/dist/configureStore";

export const getAtomInfoLabel = (atomInfo: moorhen.AtomInfo) => {
    return `/${atomInfo.mol_name}/${atomInfo.chain_id}/${atomInfo.res_no}(${atomInfo.res_name})/${atomInfo.name}${atomInfo.has_altloc ? `:${atomInfo.alt_loc}` : ""}`
}

export const getCentreAtom = async (molecules: moorhen.Molecule[], commandCentre: React.RefObject&lt;moorhen.CommandCentre>, glRef: React.RefObject&lt;webGL.MGWebGL>): Promise&lt;[moorhen.Molecule, string]> => {
    const visibleMolecules: moorhen.Molecule[] = molecules.filter((molecule: moorhen.Molecule) => molecule.isVisible())
    if (visibleMolecules.length === 0) {
        return [null, null]
    }
    const response = await commandCentre.current.cootCommand({
        returnType: "int_string_pair",
        command: "get_active_atom",
        commandArgs: [...glRef.current.origin.map(coord => coord * -1), visibleMolecules.map(molecule => molecule.molNo).join(':')]
    }, false) as moorhen.WorkerResponse&lt;libcootApi.PairType&lt;number, string>>
    const moleculeMolNo: number = response.data.result.result.first
    const residueCid: string = response.data.result.result.second
    const selectedMolecule = visibleMolecules.find((molecule: moorhen.Molecule) => molecule.molNo === moleculeMolNo)
    return [selectedMolecule, residueCid]
}

export const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

export const formatLigandSVG = (svg: string): string => {
    
    const parser = new DOMParser()
    let theText = svg
    let doc = parser.parseFromString(theText, "image/svg+xml")
    let xmin = 999
    let ymin = 999
    let xmax = -999
    let ymax = -999
    
    let lines = doc.getElementsByTagName("line")
    for (let l of lines) {
        const x1 = parseFloat(l.getAttribute("x1"))
        const y1 = parseFloat(l.getAttribute("y1"))
        const x2 = parseFloat(l.getAttribute("x2"))
        const y2 = parseFloat(l.getAttribute("y2"))
        if(x1>xmax) xmax = x1
        if(x1&lt;xmin) xmin = x1
        if(y1>ymax) ymax = y1
        if(y1&lt;ymin) ymin = y1
        if(x2>xmax) xmax = x2
        if(x2&lt;xmin) xmin = x2
        if(y2>ymax) ymax = y2
        if(y2&lt;ymin) ymin = y2
    }
    
    let texts = doc.getElementsByTagName("text");
    for (let t of texts) {
        const x = parseFloat(t.getAttribute("x"))
        const y = parseFloat(t.getAttribute("y"))
        if(x>xmax) xmax = x
        if(x&lt;xmin) xmin = x
        if(y>ymax) ymax = y
        if(y&lt;ymin) ymin = y
    }
    
    let polygons = doc.getElementsByTagName("polygon");
    for (let poly of polygons) {
        const points = poly.getAttribute("points").trim().split(" ")
        for (const point of points) {
            const xy = point.split(",")
            const x = parseFloat(xy[0])
            const y = parseFloat(xy[1])
            if(x>xmax) xmax = x
            if(x&lt;xmin) xmin = x
            if(y>ymax) ymax = y
            if(y&lt;ymin) ymin = y
        }
    }

    xmin -= 20
    ymin -= 20
    xmax += 30
    ymax -= ymin - 10
    let svgs = doc.getElementsByTagName("svg")
    const viewBoxStr = xmin+" "+ymin+" "+xmax+" "+ymax
    for (let item of svgs) {
        item.setAttribute("viewBox" , viewBoxStr)
        item.setAttribute("width" , "100%")
        item.setAttribute("height" , "100%")
        theText = item.outerHTML
    }
    
    return theText 
}

export const rgbToHsv = (r: number, g:number, b:number): [number, number, number] => {
    const cMax = Math.max(r, g, b)
    const cMin = Math.min(r, g, b)
    const delta = cMax - cMin

    let hue: number
    if (delta === 0) {
        hue = 0
    } else if (r === cMax) {
        hue = 60 * (((g - b) / delta) % 6)
    } else if (g === cMax) {
        hue = 60 * (((b - r) / delta) + 2)
    } else {
        hue = 60 * (((r - g) / delta) + 4)
    }

    let saturation: number
    if (cMax === 0) {
        saturation = 0
    } else {
        saturation = delta / cMax
    }

    return [hue, saturation, cMax]
}

export const hsvToRgb = (hue: number, saturation: number, value: number): [number, number, number] => {
    const c = value * saturation
    const x = c * (1 - Math.abs((hue / 60) % 2 - 1))
    const m = value - c
    let rgb: [number, number, number]

    if (0 &lt;= hue &amp;&amp; hue &lt; 60) {
        rgb = [c, x, 0]
    } else if (60 &lt;= hue &amp;&amp; hue &lt; 120) {
        rgb = [x, c, 0]
    } else if (120 &lt;= hue &amp;&amp; hue &lt; 180) {
        rgb = [0, c, x]
    } else if (180 &lt;= hue &amp;&amp; hue &lt; 240) {
        rgb = [0, x, c]
    } else if (240 &lt;= hue &amp;&amp; hue &lt; 300) {
        rgb = [x, 0, c]
    } else if (300 &lt;= hue &amp;&amp; hue &lt; 360) {
        rgb = [c, 0, x]
    }

    return rgb.map(component => component + m) as [number, number, number]
}

// From: https://stackoverflow.com/a/44134328
export const hslToHex = (h: number, s: number, l: number) => {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = (n: number) => {
      const k = (n + h / 30) % 12;
      const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

export const getRandomPastelColour = () => {
    const randomHue = Math.floor(Math.random() * 360);
    return hslToHex(randomHue, 80, 70)
}

export const getRandomMoleculeColour = (min: number = 127, max: number = 160) => {
    const randomComponent_A = Math.floor(Math.random() * (max - min + 1)) + min
    const randomComponent_B = max
    const randomComponent_C = min
    let result = [randomComponent_A, randomComponent_B, randomComponent_C]
    result = result.sort((a, b) => 0.5 - Math.random());
    return rgbToHex(...result as [number, number, number])
}

export function guid(): string {
    let d = Date.now();
    let uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r &amp; 0x3 | 0x8)).toString(16);
    });
    return uuid;
}

export function sequenceIsValid(sequence: moorhen.ResidueInfo[]): boolean {
    // If no sequence is present
    if (!sequence || sequence.length === 0) {
        return false
    }
    // If any residue doesn't have rigth attributes
    if (sequence.some(residue => !Object.keys(residue).includes('resNum') || !Object.keys(residue).includes('resCode'))) {
        return false
    }
    // If any of the residues has undefined or Nan as the residue code or residue number
    if (sequence.some(residue => residue.resNum === null || isNaN(residue.resNum) || typeof residue.resNum === 'undefined' || residue.resCode === null || typeof residue.resCode === 'undefined')) {
        return false
    }
    return true
}

/**
 * A function to load session data 
 * @param {moorhen.backupSession} sessionData - An object containing session data
 * @param {string} monomerLibraryPath - Path to the monomer library
 * @param {moorhen.Molecule[]} molecules - State containing current molecules loaded in the session
 * @param {moorhen.Map[]} maps - State containing current maps loaded in the session
 * @param {React.RefObject&lt;moorhen.CommandCentre>} commandCentre - React reference to the command centre
 * @param {React.RefObject&lt;moorhen.TimeCapsule>} timeCapsuleRef - React reference to the time capsule
 * @param {React.RefObject&lt;webGL.MGWebGL>} glRef - React reference to the webGL renderer
 * @param {Dispatch&lt;AnyAction>} dispatch - Dispatch method for the MoorhenReduxStore
 * @returns {number} Returns -1 if there was an error loading the session otherwise 0
 */
export async function loadSessionData(
    sessionData: moorhen.backupSession,
    monomerLibraryPath: string,
    molecules: moorhen.Molecule[],
    maps: moorhen.Map[],
    commandCentre: React.RefObject&lt;moorhen.CommandCentre>,
    timeCapsuleRef: React.RefObject&lt;moorhen.TimeCapsule>,
    glRef: React.RefObject&lt;webGL.MGWebGL>,
    store: ToolkitStore,
    dispatch: Dispatch&lt;AnyAction>
): Promise&lt;number> {

    if (!sessionData) {
        return -1
    } else if (!Object.hasOwn(sessionData, 'version') || timeCapsuleRef.current.version !== sessionData.version) {
        console.warn('Outdated session backup version, wont load...')
        return -1
    }
    
    // Delete current scene
    molecules.forEach(molecule => {
        molecule.delete()
    })

    maps.forEach(map => {
        map.delete()
    })
    
    batch(() => {
        dispatch( emptyMolecules() )
        dispatch( emptyMaps() )    
    })

    // Load molecules stored in session from coords string
    const newMoleculePromises = sessionData.moleculeData?.map(storedMoleculeData => {
        const newMolecule = new MoorhenMolecule(commandCentre, glRef, store, monomerLibraryPath)
        return newMolecule.loadToCootFromString(storedMoleculeData.coordString, storedMoleculeData.name)
    }) || []
    
    // Load maps stored in session
    const newMapPromises = sessionData.mapData?.map(storedMapData => {
        const newMap = new MoorhenMap(commandCentre, glRef, store)
        if (sessionData.includesAdditionalMapData) {
            return newMap.loadToCootFromMapData(
                storedMapData.mapData, 
                storedMapData.name, 
                storedMapData.isDifference
                )
        } else {
            newMap.uniqueId = storedMapData.uniqueId
            return timeCapsuleRef.current.retrieveBackup(
                JSON.stringify({
                    type: 'mapData',
                    name: storedMapData.uniqueId
                })
                ).then(mapData => {
                    return newMap.loadToCootFromMapData(
                        mapData as Uint8Array, 
                        storedMapData.name, 
                        storedMapData.isDifference
                        )
                    })    
        }
    }) || []
    
    const loadPromises = await Promise.all([...newMoleculePromises, ...newMapPromises])
    const newMolecules = loadPromises.filter(item => item.type === 'molecule') as moorhen.Molecule[] 
    const newMaps = loadPromises.filter(item => item.type === 'map') as moorhen.Map[] 
    
    // Draw the molecules with the styles stored in session (needs to be done sequentially due to colour rules)
    for (let i = 0; i &lt; newMolecules.length; i++) {
        const molecule = newMolecules[i]
        const storedMoleculeData = sessionData.moleculeData[i]
        if (storedMoleculeData.ligandDicts) {
            await Promise.all(Object.keys(storedMoleculeData.ligandDicts).map(compId => molecule.addDict(storedMoleculeData.ligandDicts[compId])))
        }
        molecule.defaultColourRules = storedMoleculeData.defaultColourRules.map(item => {
            const colourRule = MoorhenColourRule.initFromDataObject(item, commandCentre, molecule)
            return colourRule
        })
        molecule.defaultBondOptions = storedMoleculeData.defaultBondOptions
        for (const item of storedMoleculeData.representations) {
            const colourRules = !item.colourRules ? null : item.colourRules.map(item => {
                const colourRule = MoorhenColourRule.initFromDataObject(item, commandCentre, molecule)
                return colourRule
            })
            const representation = await molecule.addRepresentation(
                item.style, item.cid, item.isCustom, colourRules, item.bondOptions
            )
            if (item.isCustom) {
                dispatch( addCustomRepresentation(representation) )
            }
        }
    }
    
    // Associate maps to reflection data
    await Promise.all(
        newMaps.map((map, index) => {
            const storedMapData = sessionData.mapData[index]
            if (sessionData.includesAdditionalMapData &amp;&amp; storedMapData.reflectionData) {
                return map.associateToReflectionData(
                    storedMapData.selectedColumns, 
                    storedMapData.reflectionData
                )
            } else if (storedMapData.associatedReflectionFileName &amp;&amp; storedMapData.selectedColumns) {
                return timeCapsuleRef.current.retrieveBackup(
                    JSON.stringify({
                        type: 'mtzData',
                        name: storedMapData.associatedReflectionFileName
                    })
                    ).then(reflectionData => {
                        return map.associateToReflectionData(
                            storedMapData.selectedColumns, 
                            reflectionData as ArrayBuffer
                        )
                    })
            }
            return Promise.resolve()
        })
    )

    // Add molecules
    newMolecules.forEach(molecule => {
        dispatch( addMolecule(molecule) )
    })

    // Add maps
    newMaps.forEach((map, index) => {
        const storedMapData = sessionData.mapData[index]
        map.showOnLoad = storedMapData.showOnLoad
        map.suggestedRadius = storedMapData.radius
        map.suggestedContourLevel = storedMapData.contourLevel
        batch(() => {
            dispatch( setMapColours({molNo: map.molNo, rgb: storedMapData.rgba.mapColour}) )
            dispatch( setNegativeMapColours({molNo: map.molNo, rgb: storedMapData.rgba.negativeDiffColour}) )
            dispatch( setPositiveMapColours({molNo: map.molNo, rgb: storedMapData.rgba.positiveDiffColour}) )
            dispatch( setMapRadius({molNo: map.molNo, radius: storedMapData.radius}) )
            dispatch( setContourLevel({molNo: map.molNo, contourLevel: storedMapData.contourLevel}) )
            dispatch( setMapAlpha({molNo: map.molNo, alpha: storedMapData.rgba.a}) )
            dispatch( setMapStyle({molNo: map.molNo, style: storedMapData.style}) )
            dispatch( addMap(map) )                
        })
    })

    // Set active map
    if (sessionData.activeMapIndex !== undefined &amp;&amp; sessionData.activeMapIndex !== -1){
        dispatch( setActiveMap(newMaps[sessionData.activeMapIndex]) )
    }

    // Set camera details
    glRef.current.setAmbientLightNoUpdate(...Object.values(sessionData.viewData.ambientLight) as [number, number, number])
    glRef.current.setSpecularLightNoUpdate(...Object.values(sessionData.viewData.specularLight) as [number, number, number])
    glRef.current.setDiffuseLightNoUpdate(...Object.values(sessionData.viewData.diffuseLight) as [number, number, number])
    glRef.current.setLightPositionNoUpdate(...Object.values(sessionData.viewData.lightPosition) as [number, number, number])
    glRef.current.setZoom(sessionData.viewData.zoom, false)
    glRef.current.set_fog_range(sessionData.viewData.fogStart, sessionData.viewData.fogEnd, false)
    glRef.current.set_clip_range(sessionData.viewData.clipStart, sessionData.viewData.clipEnd, false)
    glRef.current.doDrawClickedAtomLines = sessionData.viewData.doDrawClickedAtomLines
    glRef.current.setOrigin(sessionData.viewData.origin, false)
    glRef.current.setQuat(sessionData.viewData.quat4)
    glRef.current.specularPower = sessionData.viewData.specularPower
    batch(() => {
        dispatch(setBackgroundColor(sessionData.viewData.backgroundColor))
        dispatch(setEdgeDetectDepthScale(sessionData.viewData.edgeDetection.depthScale))
        dispatch(setEdgeDetectDepthThreshold(sessionData.viewData.edgeDetection.depthThreshold))
        dispatch(setEdgeDetectNormalScale(sessionData.viewData.edgeDetection.normalScale))
        dispatch(setEdgeDetectNormalThreshold(sessionData.viewData.edgeDetection.normalThreshold))
        dispatch(setDoEdgeDetect(sessionData.viewData.edgeDetection.enabled))
        dispatch(setDoShadow(sessionData.viewData.shadows))
        dispatch(setDoSSAO(sessionData.viewData.ssao.enabled))
        dispatch(setSsaoBias(sessionData.viewData.ssao.bias))
        dispatch(setSsaoRadius(sessionData.viewData.ssao.radius))
        dispatch(setUseOffScreenBuffers(sessionData.viewData.blur.enabled))
        dispatch(setDepthBlurDepth(sessionData.viewData.blur.depth))
        dispatch(setDepthBlurRadius(sessionData.viewData.blur.radius))
        dispatch(setUseOffScreenBuffers(sessionData.viewData.blur.enabled))
    })

    // Set connected maps and molecules if any
    const connectedMoleculeIndex = sessionData.moleculeData?.findIndex(molecule => molecule.connectedToMaps?.length > 0)
    if (sessionData.mapData &amp;&amp; sessionData.moleculeData &amp;&amp; connectedMoleculeIndex !== -1) {
        const oldConnectedMolecule = sessionData.moleculeData[connectedMoleculeIndex]        
        const molecule = newMolecules[connectedMoleculeIndex].molNo
        const [reflectionMap, twoFoFcMap, foFcMap] = oldConnectedMolecule.connectedToMaps.map(item => newMaps[sessionData.mapData.findIndex(map => map.molNo === item)].molNo)
        const connectMapsArgs = [molecule, reflectionMap, twoFoFcMap, foFcMap]
        const sFcalcArgs = [molecule, twoFoFcMap, foFcMap, reflectionMap]
        
        await commandCentre.current.cootCommand({
            command: 'connect_updating_maps',
            commandArgs: connectMapsArgs,
            returnType: 'status'
        }, false)
            
        await commandCentre.current.cootCommand({
            command: 'sfcalc_genmaps_using_bulk_solvent',
            commandArgs: sFcalcArgs,
            returnType: 'status'
        }, false)

        batch(() => {
            dispatch( setFoFcMapMolNo(foFcMap) )
            dispatch( setTwoFoFcMapMolNo(twoFoFcMap) )
            dispatch( setReflectionMapMolNo(reflectionMap) )
            dispatch( setConnectedMoleculeMolNo(molecule) )
            dispatch( enableUpdatingMaps() )
        })
    }
    
    return 0
}

export async function loadSessionFromArrayBuffer(
    sessionArrayBuffer: ArrayBuffer,
    monomerLibraryPath: string,
    molecules: moorhen.Molecule[],
    maps: moorhen.Map[],
    commandCentre: React.RefObject&lt;moorhen.CommandCentre>,
    timeCapsuleRef: React.RefObject&lt;moorhen.TimeCapsule>,
    glRef: React.RefObject&lt;webGL.MGWebGL>,
    store: ToolkitStore,
    dispatch: Dispatch&lt;AnyAction>
) {
    timeCapsuleRef.current.setBusy(true)
    const bytes = new Uint8Array(sessionArrayBuffer)
    const sessionMessage = moorhensession.Session.decode(bytes)
    const status = await loadSessionFromProtoMessage(sessionMessage, monomerLibraryPath, molecules, maps, commandCentre, timeCapsuleRef, glRef, store,  dispatch) 
    timeCapsuleRef.current.setBusy(false)
    return status
}

/**
 * A function to load session data
 * @param {string} sessionProtoMessage - A protobuf message for the object containing session data
 * @param {string} monomerLibraryPath - Path to the monomer library
 * @param {moorhen.Molecule[]} molecules - State containing current molecules loaded in the session
 * @param {moorhen.Map[]} maps - State containing current maps loaded in the session
 * @param {React.RefObject&lt;moorhen.CommandCentre>} commandCentre - React reference to the command centre
 * @param {React.RefObject&lt;moorhen.TimeCapsule>} timeCapsuleRef - React reference to the time capsule
 * @param {React.RefObject&lt;webGL.MGWebGL>} glRef - React reference to the webGL renderer
 * @param {Dispatch&lt;AnyAction>} dispatch - Dispatch method for the MoorhenReduxStore
 * @returns {number} Returns -1 if there was an error loading the session otherwise 0
 */
export async function loadSessionFromProtoMessage(
    sessionProtoMessage: any,
    monomerLibraryPath: string,
    molecules: moorhen.Molecule[],
    maps: moorhen.Map[],
    commandCentre: React.RefObject&lt;moorhen.CommandCentre>,
    timeCapsuleRef: React.RefObject&lt;moorhen.TimeCapsule>,
    glRef: React.RefObject&lt;webGL.MGWebGL>,
    store: ToolkitStore,
    dispatch: Dispatch&lt;AnyAction>
): Promise&lt;number> {

    timeCapsuleRef.current.setBusy(true)
    const sessionData = moorhensession.Session.toObject(sessionProtoMessage) as moorhen.backupSession
    const status = await loadSessionData(sessionData, monomerLibraryPath, molecules, maps, commandCentre, timeCapsuleRef, glRef, store, dispatch)
    timeCapsuleRef.current.setBusy(false)
    return status
}

/**
 * A function to load session data from a JSON string representation
 * @param {string} sessionDataString - A JSON string representation of the object containing session data
 * @param {string} monomerLibraryPath - Path to the monomer library
 * @param {moorhen.Molecule[]} molecules - State containing current molecules loaded in the session
 * @param {moorhen.Map[]} maps - State containing current maps loaded in the session
 * @param {React.RefObject&lt;moorhen.CommandCentre>} commandCentre - React reference to the command centre
 * @param {React.RefObject&lt;moorhen.TimeCapsule>} timeCapsuleRef - React reference to the time capsule
 * @param {React.RefObject&lt;webGL.MGWebGL>} glRef - React reference to the webGL renderer
 * @param {Dispatch&lt;AnyAction>} dispatch - Dispatch method for the MoorhenReduxStore
 * @returns {number} Returns -1 if there was an error loading the session otherwise 0
 */
export async function loadSessionFromJsonString(
    sessionDataString: string,
    monomerLibraryPath: string,
    molecules: moorhen.Molecule[],
    maps: moorhen.Map[],
    commandCentre: React.RefObject&lt;moorhen.CommandCentre>,
    timeCapsuleRef: React.RefObject&lt;moorhen.TimeCapsule>,
    glRef: React.RefObject&lt;webGL.MGWebGL>,
    store: ToolkitStore,
    dispatch: Dispatch&lt;AnyAction>
): Promise&lt;number> {

    timeCapsuleRef.current.setBusy(true)
    const sessionData: moorhen.backupSession = JSON.parse(sessionDataString)
    const status = await loadSessionData(sessionData, monomerLibraryPath, molecules, maps, commandCentre, timeCapsuleRef, glRef, store, dispatch)
    timeCapsuleRef.current.setBusy(false)
    return status
}

export function convertRemToPx(rem: number): number {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
}

export function convertViewtoPx(input: number, height: number): number {
    return height * (input / 100)
}

export const representationLabelMapping = {
    rama: "Rama. Balls",
    rotamer: "Rota. Dodec.",
    CBs: "Bonds",
    CAs: "C-Alpha",
    CRs: "Ribbons",
    CDs: "Cont. dots",
    MolecularSurface: "Mol Surf.",
    gaussian: "Gauss. Surf.",
    ligands: "Ligands",
    DishyBases: "Bases",
    VdwSpheres: "Spheres",
    allHBonds: "H-Bonds",
    glycoBlocks: "Glyco-Blocks",
    restraints: "Restraints",
    MetaBalls: "MetaBalls",
    adaptativeBonds: "Adapt. Bonds",
}

export const residueCodesOneToThree = {
    'C': 'CYS',
    'D': 'ASP',
    'S': 'SER',
    'Q': 'GLN',
    'K': 'LYS',
    'I': 'ILE',
    'P': 'PRO',
    'T': 'THR',
    'F': 'PHE',
    'N': 'ASN',
    'G': 'GLY',
    'H': 'HIS',
    'L': 'LEU',
    'R': 'ARG',
    'W': 'TRP',
    'A': 'ALA',
    'V': 'VAL',
    'E': 'GLU',
    'Y': 'TYR',
    'M': 'MET',
    'UNK': 'UNKOWN',
    'X': 'UNKOWN',
    '-': 'MISSING'
}

export const residueCodesThreeToOne = {
    "ALA": 'A',
    "ARG": 'R',
    "ASN": 'N',
    "ASP": 'D',
    "CYS": 'C',
    "GLN": 'Q',
    "GLU": 'E',
    "GLY": 'G',
    "HIS": 'H',
    "ILE": 'I',
    "LEU": 'L',
    "LYS": 'K',
    "MET": 'M',
    "PHE": 'F',
    "PRO": 'P',
    "SER": 'S',
    "THR": 'T',
    "TRP": 'W',
    "TYR": 'Y',
    "VAL": 'V',
    "UNK": 'X',
}

export const nucleotideCodesOneToThree = {
    "A": "A",
    "T": "T",
    "G": "G",
    "C": "C",
    "U": "U",
    "N": "N",
    "I": "I",
    "X": "UNKOWN",
    'UNK': 'UNKOWN',
    '-': 'MISSING'
}

export const nucleotideCodesThreeToOne = {
    "A": "A",
    "T": "T",
    "G": "G",
    "C": "C",
    "U": "U",
    "N": "N",
    "I": "I",
    "DT": "T",
    "DG": "G",
    "DC": "C",
    "DA": "A",
    "DU": "U",
    "ADE": "A",
    "THY": "T",
    "GUA": "G",
    "CYT": "C",
    "URA": "U",
    "PSU": "U",
    "UNKOWN": "X",
    'UNK': 'X',
    'MISSING': '-'
}

export const windowsFonts = [
    'Arial', 'Arial Black', 'Bahnschrift', 'Calibri', 'Cambria', 'Cambria Math', 'Candara', 'Comic Sans MS', 'Consolas', 'Constantia',
    'Corbel', 'Courier New', 'Ebrima', 'Franklin Gothic Medium', 'Gabriola', 'Gadugi', 'Georgia', 'HoloLens MDL2 Assets', 'Impact',
    'Ink Free', 'Javanese Text', 'Leelawadee UI', 'Lucida Console', 'Lucida Sans Unicode', 'Malgun Gothic', 'Marlett', 'Microsoft Himalaya',
    'Microsoft JhengHei', 'Microsoft New Tai Lue', 'Microsoft PhagsPa', 'Microsoft Sans Serif', 'Microsoft Tai Le', 'Microsoft YaHei',
    'Microsoft Yi Baiti', 'MingLiU-ExtB', 'Mongolian Baiti', 'MS Gothic', 'MV Boli', 'Myanmar Text', 'Nirmala UI', 'Palatino Linotype',
    'Segoe MDL2 Assets', 'Segoe Print', 'Segoe Script', 'Segoe UI', 'Segoe UI Historic', 'Segoe UI Emoji', 'Segoe UI Symbol', 'SimSun',
    'Sitka', 'Sylfaen', 'Symbol', 'Tahoma', 'Times New Roman', 'Trebuchet MS', 'Verdana', 'Webdings', 'Wingdings', 'Yu Gothic'
]

export const macFonts = [
    'American Typewriter', 'Andale Mono', 'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold', 'Arial Unicode MS', 'Avenir',
    'Avenir Next', 'Avenir Next Condensed', 'Baskerville', 'Big Caslon', 'Bodoni 72', 'Bodoni 72 Oldstyle', 'Bodoni 72 Smallcaps', 'Bradley Hand',
    'Brush Script MT', 'Chalkboard', 'Chalkboard SE', 'Chalkduster', 'Charter', 'Cochin', 'Comic Sans MS', 'Copperplate', 'Courier', 'Courier New',
    'Didot', 'DIN Alternate', 'DIN Condensed', 'Futura', 'Geneva', 'Georgia', 'Gill Sans', 'Helvetica', 'Helvetica Neue', 'Herculanum', 'Hoefler Text',
    'Impact', 'Lucida Grande', 'Luminari', 'Marker Felt', 'Menlo', 'Microsoft Sans Serif', 'Monaco', 'Noteworthy', 'Optima', 'Palatino', 'Papyrus',
    'Phosphate', 'Rockwell', 'Savoye LET', 'SignPainter', 'Skia', 'Snell Roundhand', 'Tahoma', 'Times', 'Times New Roman', 'Trattatello', 'Trebuchet MS',
    'Verdana', 'Zapfino'
]

export const linuxFonts = [
    "Liberation Sans", "Nimbus Sans L", "FreeSans", "DejaVu Sans", "Bitstream Vera Sans", "Geneva", "Liberation Serif", "Nimbus Roman No 9 L",
    "FreeSerif", "Hoefler Text", "Times", "Times New Roman", "Bitstream Charter", "URW Palladio L", "Palatino", "Palatino Linotype", "Book Antiqua",
    "DejaVu Serif", "Bitstream Vera Serif", "Century Schoolbook L", "Lucida Bright", "Georgia", "Liberation Mono", "Nimbus Mono L", "FreeMono",
    "Bitstream Vera Mono", "Lucida Console", "DejaVu Mono"
]

export const webSafeFonts = [
    "Comic Sans", "Courier New", "Georgia", "Times New Roman", "Verdana", "Trebuchet MS", "Palatino", "Tahoma", "Arial", "Impact"
]

export const allFontsSet = new Set([webSafeFonts, windowsFonts, macFonts, linuxFonts].flat().sort());

export const readTextFile = (source: File): Promise&lt;ArrayBuffer | string> => {
    const resolveReader = (reader: FileReader, resolveCallback) => {
        reader.removeEventListener("load", resolveCallback)
        resolveCallback(reader.result)
    }

    return new Promise((resolve, reject) => {
        const reader: FileReader = new FileReader();
        reader.addEventListener("load", () => resolveReader(reader, resolve))
        reader.readAsText(source);
    })
}

export const readDataFile = (source: File): Promise&lt;ArrayBuffer> => {
    const resolveReader = (reader: FileReader, resolveCallback) => {
        reader.removeEventListener("load", resolveCallback)
        if (typeof reader.result === 'string') {
            resolveCallback(JSON.parse(reader.result));
        } else {
            resolveCallback(reader.result)
        }
    }

    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener("load", () => resolveReader(reader, resolve))
        reader.readAsArrayBuffer(source)
    })
}

const downloadFile = (file: File, fileName: string) => {
    const url = window.URL.createObjectURL(file);
    
    const link = document.createElement('a');
    link.download = fileName;
    link.href = url;

    document.body.appendChild(link);

    link.click();

    link.parentNode.removeChild(link);
    window.URL.revokeObjectURL(url);
}

export const doDownload = (data: BlobPart[], fileName: string) => {
    const file = new File(data, fileName, { type: 'application/octet-stream' });
    downloadFile(file, fileName)
}

export const doDownloadText = (text: string, fileName: string) => {
    const file = new File([text], fileName, { type: 'text/plain' });
    downloadFile(file, fileName)
}

export const readGemmiStructure = (coordData: ArrayBuffer | string, molName: string): gemmi.Structure => {
    const structure: gemmi.Structure = window.CCP4Module.read_structure_from_string(coordData, molName)
    return structure
}

export const centreOnGemmiAtoms = (atoms: moorhen.AtomInfo[]): [number, number, number] => {
    const atomCount = atoms.length
    if (atomCount === 0) {
        return [0, 0, 0]
    }

    let xtot = 0.0
    let ytot = 0.0
    let ztot = 0.0

    for (const atom of atoms) {
        xtot += atom.x
        ytot += atom.y
        ztot += atom.z
    }

    return [-xtot / atomCount, -ytot / atomCount, -ztot / atomCount]
}

export const atomInfoToResSpec = (atom: moorhen.AtomInfo) => {
    return { 
        mol_no: atom.mol_name,
        chain_id: atom.chain_id,
        res_no: parseInt(atom.res_no), 
        res_name: atom.res_name,
        atom_name: atom.name,
        // FIXME: Atom info does not contain a ins_code field ?? Or is it atom.serial ?
        ins_code: "",
        alt_conf: atom.alt_loc,
        cid: getAtomInfoLabel(atom),
        // FIXME: Atom info does not contain a model name. This is probably not a problem...
        mol_name: "",
    }
}

export const cidToSpec = (cid: string): moorhen.ResidueSpec => {
    //molNo, chain_id, res_no, ins_code, alt_conf
    const ResNameRegExp = /\(([^)]+)\)/;
    const cidTokens = cid.split('/')
    const mol_name = cidTokens[0]
    const mol_no = cidTokens[1]
    const chain_id = cidTokens[2]
    const res_no = parseInt(cidTokens[3])
    const res_name = ResNameRegExp.exec(cidTokens[3])?.length > 0 ? ResNameRegExp.exec(cidTokens[3])[0].replace('(', '').replace(')', '') : null
    const ins_code = (cidTokens.length > 3 &amp;&amp; cidTokens[3].split(".").length > 1) ? cidTokens[3].split(".")[1] : ""
    const atom_name = cidTokens.length > 4 ? cidTokens[4].split(":")[0] : ""
    const alt_conf = atom_name &amp;&amp; cidTokens[4].split(":").length > 1 ? cidTokens[4].split(":")[1] : ""
    return { mol_name, mol_no, chain_id, res_no, res_name, atom_name, ins_code, alt_conf, cid }
}


export const cidToAtomInfo = (cid: string): moorhen.AtomInfo => {
    const resSpec = cidToSpec(cid)
    return {
        x: null,
        y: null,
        z: null,
        charge: null,
        element: null,
        tempFactor: null,
        serial: null,
        name: resSpec.atom_name,
        has_altloc: resSpec.alt_conf !== "",
        alt_loc: resSpec.alt_conf,
        mol_name: resSpec.mol_no,
        chain_id: resSpec.chain_id,
        res_no: resSpec.res_no.toString(),
        res_name: resSpec.res_name,
    }
}

type ResidueInfoType = {
    modelIndex: number;
    molName: string;
    chain: string;
    seqNum: number;
    resCode: string;
}

export const getResidueInfo = (molecules: moorhen.Molecule[], selectedMolNo: number, selectedChain: string, selectedResidueIndex: number): ResidueInfoType => {
    const selectedMolecule = molecules.find(molecule => molecule.molNo === selectedMolNo)
    if (selectedMolecule) {
        const sequence = selectedMolecule.sequences.find(sequence => sequence.chain === selectedChain)
        if (sequence) {
            const sequenceData = sequence.sequence
            const { resNum, resCode } = sequenceData[selectedResidueIndex];
            if (resNum &amp;&amp; resNum > -1) {
                return {
                    modelIndex: 0,
                    molName: selectedMolecule.name,
                    chain: selectedChain,
                    seqNum: resNum,
                    resCode: resCode
                }
            }
        }
    }
}

export const getTooltipShortcutLabel = (shortCut: moorhen.Shortcut): string => {
    let modifiers = []
    if (shortCut.modifiers.includes('shiftKey')) modifiers.push("Shift")
    if (shortCut.modifiers.includes('ctrlKey')) modifiers.push("&lt;Ctrl>")
    if (shortCut.modifiers.includes('metaKey')) modifiers.push("&lt;Meta>")
    if (shortCut.modifiers.includes('altKey')) modifiers.push("&lt;Alt>")
    if (shortCut.keyPress === " ") modifiers.push("&lt;Space>")
    return modifiers.length > 0 ? `&lt;${modifiers.join(" ")} ${shortCut.keyPress.toUpperCase()}>` : `&lt;${shortCut.keyPress.toUpperCase()}>`
}

export function componentToHex(c: number): string {
    const hex = c.toString(16)
    return hex.length === 1 ? "0" + hex : hex
}

export function rgbToHex(r: number, g: number, b: number): string {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b)
}

const getChainColourRamp = (residueCids: string[]) => {
    const delta = 240 / residueCids.length
    const colours = residueCids.map((cid, index) => {
        const rgb = hsvToRgb(240 - Math.round(delta * index), 1, 1)
        const hex = rgbToHex(...rgb.map(i => Math.round(i * 255)) as [number, number, number])
        return `${cid}^${hex}`
    })
    return colours.join('|')
}

const getBfactorColourRules = (bFactors: { cid: string; bFactor: number; normalised_bFactor: number }[], normaliseBFactors: boolean = true): string => {
    const getColour = (bFactor: number): string => {
        let r: number, g: number, b: number
        if (bFactor &lt;= 25) {
            r = 0
            g = Math.round(10.2 * bFactor)
            b = 255
        } else if (bFactor &lt;= 50) {
            r = 0
            g = 255
            b = Math.round(510 - 10.2 * bFactor)
        } else if (bFactor &lt;= 75) {
            r = Math.round(10.2 * (bFactor - 50))
            g = 255
            b = 0
        } else {
            r = 255
            g = Math.round(510 - 10.2 * (bFactor - 50))
            b = 0
        }
        return rgbToHex(r, g, b)
    }
    
    const bFactorAttr = normaliseBFactors ? 'normalised_bFactor' : 'bFactor'
    return bFactors.map(item => `${item.cid}^${getColour(item[bFactorAttr])}`).join('|')
}

const getPlddtColourRules = (plddtList: { cid: string; bFactor: number; }[]): string => {
    const getColour = (plddt: number) => {
        let r: number, g: number, b: number
        if (plddt &lt;= 50) {
            r = 230
            g = 113
            b = 62
        } else if (plddt &lt;= 70) {
            r = 230
            g = 197
            b = 17
        } else if (plddt &lt; 90) {
            r = 91
            g = 183
            b = 219
        } else {
            r = 0
            g = 75
            b = 193
        }
        return rgbToHex(r, g, b)
    }

    return plddtList.map(item => `${item.cid}^${getColour(item.bFactor)}`).join('|')
}

const getNcsColourRules = (ncsRelatedChains: string[][]): string => {
    let result: string[]  = []
    ncsRelatedChains.forEach(chains => {
        const randColour = getRandomMoleculeColour()
        chains.forEach(chain => {
            result.push(`//${chain}^${randColour}`)
        })
    })
    return result.join('|')
}

const getSecondaryStructureColourRules = (secondaryStructureInfo: libcootApi.ResidueSpecJS[]): string => {
    let result: string[] = []
    let chainSS2Info: { [chainId: string]: { [ss2: number]: number[] } } = {}

    const alphaHelix = '#d13d62'
    const betaStrand = '#4b57bd'
    const turn = '#d1c03d'
    
    secondaryStructureInfo.forEach(residue => {
        if (!(residue.chainId in chainSS2Info)) {
            chainSS2Info[residue.chainId] = { 1: [], 2: [], 3: [] }
        }
        const ss2Type = residue.intUserData === 6 ? 1 : [1, 2].includes(residue.intUserData) ? 2 : 3
        chainSS2Info[residue.chainId][ss2Type].push(residue.resNum)
    })
    
    for (let chainId in chainSS2Info) {
        for (let ss2Info in chainSS2Info[chainId]) {
            if (chainSS2Info[chainId][ss2Info].length > 0) {
                const residueRanges = findConsecutiveRanges(chainSS2Info[chainId][ss2Info])
                residueRanges.forEach(residueRange => {
                    result.push(`//${chainId}/${residueRange[0]}-${residueRange[1]}^${ss2Info === '1' ? alphaHelix : ss2Info === '2' ? betaStrand : turn}`)
                })
            }
        }
    }

    return result.join('|')
}

export const getMultiColourRuleArgs = async (molecule: moorhen.Molecule, ruleType: string): Promise&lt;string> => {

    let multiRulesArgs: string
    switch (ruleType) {
        case 'secondary-structure':
            const secondaryStructureInfo = await molecule.getSecondaryStructInfo()
            multiRulesArgs = getSecondaryStructureColourRules(secondaryStructureInfo)
            break;
        case 'jones-rainbow':
            const chainResidueInfo = molecule.sequences.map(sequence => sequence.sequence.map(residue => {
                return residue.cid
            }))
            multiRulesArgs = chainResidueInfo.map(chainInfo => getChainColourRamp(chainInfo)).join("|")
            break;
        case 'b-factor':
        case 'b-factor-norm':
            const bFactors = molecule.getResidueBFactors()
            multiRulesArgs = getBfactorColourRules(bFactors, ruleType === 'b-factor-norm')
            break;
        case 'af2-plddt':
            const plddt = molecule.getResidueBFactors()
            multiRulesArgs = getPlddtColourRules(plddt)
            break;
        case 'mol-symm':
            const ncsRelatedChains = await molecule.getNcsRelatedChains()
            multiRulesArgs = getNcsColourRules(ncsRelatedChains)
            break;
        default:
            console.log('Unrecognised colour rule...')
            break;
    }

    return multiRulesArgs
}

export const hexToHsl = (hex: string): [number, number, number] => {
    let [r, g, b]: number[] = hexToRgb(hex).replace('rgb(', '').replace(')', '').split(', ').map(item => parseFloat(item))
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h: number, s: number, l: number = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
            default: break;
        }

        h /= 6;
    }

    return [h, s, l];
}

export const createLocalStorageInstance = (name: string, empty: boolean = false): moorhen.LocalStorageInstance => {
    const instance = localforage.createInstance({
        driver: [localforage.INDEXEDDB, localforage.LOCALSTORAGE],
        name: name,
        storeName: name
    })
    if (empty) {
        instance.clear()
    }
    return instance
}

export const getDashedCylinder = (nsteps: number, cylinder_accu: number): [number[], number[], number[]] => {
    let thisPos = []
    let thisNorm = []
    let thisIdxs = []

    let ipos = 0
    let maxIdx = 0

    const dash_step = 1.0 / nsteps

    for (let i = 0; i &lt; nsteps / 2; i++, ipos += 2) {
        const z = ipos * dash_step;
        const zp1 = (ipos + 1) * dash_step;
        for (let j = 0; j &lt; 360; j += 360 / cylinder_accu) {
            const theta1 = j * Math.PI / 180.0;
            const theta2 = (j + 360 / cylinder_accu) * Math.PI / 180.0;
            const x1 = Math.sin(theta1);
            const y1 = Math.cos(theta1);
            const x2 = Math.sin(theta2);
            const y2 = Math.cos(theta2);
            thisNorm.push(...[x1, y1, 0.0])
            thisNorm.push(...[x1, y1, 0.0])
            thisNorm.push(...[x2, y2, 0.0])
            thisNorm.push(...[x2, y2, 0.0])
            thisPos.push(...[x1, y1, z])
            thisPos.push(...[x1, y1, zp1])
            thisPos.push(...[x2, y2, z])
            thisPos.push(...[x2, y2, zp1])
            thisIdxs.push(...[0 + maxIdx, 1 + maxIdx, 2 + maxIdx])
            thisIdxs.push(...[1 + maxIdx, 3 + maxIdx, 2 + maxIdx])
            maxIdx += 4
            thisPos.push(...[x1, y1, z])
            thisPos.push(...[x2, y2, z])
            thisPos.push(...[0.0, 0.0, z])
            thisNorm.push(...[0.0, 0.0, 1.0])
            thisNorm.push(...[0.0, 0.0, 1.0])
            thisNorm.push(...[0.0, 0.0, 1.0])
            thisIdxs.push(...[0 + maxIdx, 2 + maxIdx, 1 + maxIdx])
            maxIdx += 3
            thisPos.push(...[x1, y1, zp1])
            thisPos.push(...[x2, y2, zp1])
            thisPos.push(...[0.0, 0.0, zp1])
            thisNorm.push(...[0.0, 0.0, -1.0])
            thisNorm.push(...[0.0, 0.0, -1.0])
            thisNorm.push(...[0.0, 0.0, -1.0])
            thisIdxs.push(...[0 + maxIdx, 1 + maxIdx, 2 + maxIdx])
            maxIdx += 3
        }
    }

    return [thisPos, thisNorm, thisIdxs]
}

export const gemmiAtomPairsToCylindersInfo = (
    atoms: [{ x: number, y: number, z: number, serial: (number | string) }, { x: number, y: number, z: number, serial: (number | string) }][],
    size: number,
    colourScheme: { [x: string]: number[]; },
    labelled: boolean = false,
    minDist: number = 1.9,
    maxDist: number = 4.0,
    dashed: boolean = true
) => {

    let atomPairs = atoms;

    let totIdxs = []
    let totPos = []
    let totNorm = []
    let totInstance_sizes = []
    let totInstance_colours = []
    let totInstance_origins = []
    let totInstance_orientations = []
    let totInstanceUseColours = []
    let totInstancePrimTypes = []

    const [thisPos, thisNorm, thisIdxs] = getDashedCylinder(dashed ? 15 : 1, 16);

    let thisInstance_sizes = []
    let thisInstance_colours = []
    let thisInstance_origins = []
    let thisInstance_orientations = []

    let totTextPrimTypes = []
    let totTextIdxs = []
    let totTextPrimPos = []
    let totTextPrimNorm = []
    let totTextPrimCol = []
    let totTextLabels = []


    for (let iat = 0; iat &lt; atomPairs.length; iat++) {
        const at0 = atomPairs[iat][0];
        const at1 = atomPairs[iat][1];
        let ab = vec3.create()
        let midpoint = vec3.create()

        vec3.set(ab, at0.x - at1.x, at0.y - at1.y, at0.z - at1.z)
        vec3.set(midpoint, 0.5 * (at0.x + at1.x), 0.5 * (at0.y + at1.y), 0.5 * (at0.z + at1.z))
        const l = vec3.length(ab)

        totTextLabels.push(l.toFixed(2))
        totTextIdxs.push(iat) // Meaningless, I think
        totTextPrimNorm.push(...[0, 0, 1]) // Also meaningless, I think
        totTextPrimPos.push(...[midpoint[0], midpoint[1], midpoint[2]])

        if (l > maxDist || l &lt; minDist) continue;

        for (let ip = 0; ip &lt; colourScheme[`${at0.serial}`].length; ip++) {
            thisInstance_colours.push(colourScheme[`${at0.serial}`][ip])
            totTextPrimCol.push(colourScheme[`${at0.serial}`][ip])
        }
        thisInstance_origins.push(at0.x, at0.y, at0.z)
        thisInstance_sizes.push(...[size, size, l])
        let v = vec3.create()
        let au = vec3.create()
        let a = vec3.create()
        let b = vec3.create()
        const aup = [
            at0.x - at1.x,
            at0.y - at1.y,
            at0.z - at1.z
        ]
        vec3.set(au, ...aup)
        vec3.normalize(a, au)
        vec3.set(b, 0.0, 0.0, -1.0)
        vec3.cross(v, a, b)
        const c = vec3.dot(a, b)
        if (Math.abs(c + 1.0) &lt; 1e-4) {
            thisInstance_orientations.push(...[
                -1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, -1.0, 0.0,
                0.0, 0.0, 0.0, 1.0,
            ])
        } else {
            const s = vec3.length(v)
            let k = mat3.create()
            k.set([
                0.0, -v[2], v[1],
                v[2], 0.0, -v[0],
                -v[1], v[0], 0.0,
            ])
            let kk = mat3.create()
            mat3.multiply(kk, k, k)
            let sk = mat3.create()
            mat3.multiplyScalar(sk, k, 1.0)
            let omckk = mat3.create()
            mat3.multiplyScalar(omckk, kk, 1.0 / (1.0 + c))
            let r = mat3.create()
            r.set([
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 0.0, 1.0,
            ])
            mat3.add(r, r, sk)
            mat3.add(r, r, omckk)
            thisInstance_orientations.push(...[
                r[0], r[1], r[2], 1.0,
                r[3], r[4], r[5], 1.0,
                r[6], r[7], r[8], 1.0,
                0.0, 0.0, 0.0, 1.0,
            ])
        }
    }

    totNorm.push(thisNorm)
    totPos.push(thisPos)
    totIdxs.push(thisIdxs)
    totInstance_sizes.push(thisInstance_sizes)
    totInstance_origins.push(thisInstance_origins)
    totInstance_orientations.push(thisInstance_orientations)
    totInstance_colours.push(thisInstance_colours)
    totInstanceUseColours.push(true)
    totInstancePrimTypes.push("TRIANGLES")
    if (labelled)
        totTextPrimTypes.push("TEXTLABELS")

    if (labelled)
        return {
            prim_types: [totInstancePrimTypes, totTextPrimTypes],
            idx_tri: [totIdxs, totTextIdxs],
            vert_tri: [totPos, totTextPrimPos],
            norm_tri: [totNorm, totTextPrimNorm],
            col_tri: [totInstance_colours, totTextPrimCol],
            label_tri: [[], totTextLabels],
            instance_use_colors: [totInstanceUseColours, [false]],
            instance_sizes: [totInstance_sizes, []],
            instance_origins: [totInstance_origins, []],
            instance_orientations: [totInstance_orientations, []]
        }
    else
        return {
            prim_types: [totInstancePrimTypes],
            idx_tri: [totIdxs],
            vert_tri: [totPos],
            norm_tri: [totNorm],
            col_tri: [totInstance_colours],
            instance_use_colors: [totInstanceUseColours],
            instance_sizes: [totInstance_sizes],
            instance_origins: [totInstance_origins],
            instance_orientations: [totInstance_orientations]
        }

}

export const gemmiAtomsToCirclesSpheresInfo = (atoms: moorhen.AtomInfo[], size: number, primType: string, colourScheme: { [x: string]: any[]; }) => {

    let sphere_sizes = [];
    let sphere_col_tri = [];
    let sphere_vert_tri = [];
    let sphere_idx_tri = [];
    let sphere_atoms = [];

    let totInstanceUseColours = []
    let totInstance_orientations = []

    for (let iat = 0; iat &lt; atoms.length; iat++) {
        sphere_idx_tri.push(iat);
        sphere_vert_tri.push(atoms[iat].x);
        sphere_vert_tri.push(atoms[iat].y);
        sphere_vert_tri.push(atoms[iat].z);
        for (let ip = 0; ip &lt; colourScheme[`${atoms[iat].serial}`].length; ip++) {
            sphere_col_tri.push(colourScheme[`${atoms[iat].serial}`][ip])
        }
        sphere_sizes.push(size);
        sphere_atoms.push(atoms[iat]);
        if (primType === "PERFECT_SPHERES") {
            totInstanceUseColours.push(true);
            totInstance_orientations.push(...[
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0,
            ])
            sphere_sizes.push(size);
            sphere_sizes.push(size);
        }
    }

    if (primType === "PERFECT_SPHERES") {
        return {
            atoms: [[sphere_atoms]],
            instance_sizes: [[sphere_sizes]],
            instance_origins: [[sphere_vert_tri]],
            instance_use_colors: [[totInstanceUseColours]],
            instance_orientations: [[totInstance_orientations]],
            col_tri: [[sphere_col_tri]],
            norm_tri: [[[sphere_vert_tri]]],
            vert_tri: [[sphere_vert_tri]],
            idx_tri: [[sphere_idx_tri]],
            prim_types: [[primType]]
        }
    } else {
        return {
            atoms: [[sphere_atoms]],
            sizes: [[sphere_sizes]],
            col_tri: [[sphere_col_tri]],
            norm_tri: [[[]]],
            vert_tri: [[sphere_vert_tri]],
            idx_tri: [[sphere_idx_tri]],
            prim_types: [[primType]]
        }
    }
}

export const findConsecutiveRanges = (numbers: number[]): [number, number][] => {
    numbers.sort((a, b) => a - b);
    const ranges: [number, number][] = [];

    let start = numbers[0];
    let end = numbers[0];

    for (let i = 1; i &lt; numbers.length; i++) {
        if (numbers[i] === end + 1) {
            end = numbers[i];
        } else {
            ranges.push([start, end]);
            start = numbers[i];
            end = numbers[i];
        }
    }

    ranges.push([start, end]);
    return ranges;
}

export function getCubeLines(unitCell: gemmi.UnitCell): [{ x: number, y: number, z: number, serial: string }, { x: number, y: number, z: number, serial: string }][] {

    const orthogonalize = (x: number, y: number, z: number) => {
        const fractPosition = new window.CCP4Module.Fractional(x, y, z)
        const orthPosition = unitCell.orthogonalize(fractPosition)
        const result = [orthPosition.x, orthPosition.y, orthPosition.z] as [number, number, number]
        fractPosition.delete()
        orthPosition.delete()
        return result
    }

    const vertices: [number, number, number][] = [
        [0, 0, 0],
        [1, 0, 0],
        [1, 1, 0],
        [0, 1, 0],
        [0, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 1, 1]
    ];

    const edges: [number, number][] = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 0],
        [4, 5],
        [5, 6],
        [6, 7],
        [7, 4],
        [0, 4],
        [1, 5],
        [2, 6],
        [3, 7]
    ];

    const lines: [{ x: number, y: number, z: number, serial: string }, { x: number, y: number, z: number, serial: string }][] = [];
    edges.forEach(edge => {
        const [v1Index, v2Index] = edge
        
        const [v1_x, v1_y, v1_z] = orthogonalize(...vertices[v1Index])
        const v1 = {
            x: v1_x,
            y: v1_y,
            z: v1_z,
            serial: 'unit_cell'
        };
        
        const [v2_x, v2_y, v2_z] = orthogonalize(...vertices[v2Index])
        const v2 = {
            x: v2_x,
            y: v2_y,
            z: v2_z,
            serial: 'unit_cell'
        };
        lines.push([v1, v2]);
    })

    return lines;
}

export const countResiduesInSelection = (gemmiStructure: gemmi.Structure, cidSelection?: string) => {
    const selection = new window.CCP4Module.Selection(cidSelection ? cidSelection : '/*/*/*')
    const count = window.CCP4Module.count_residues_in_selection(gemmiStructure, selection)
    selection.delete()
    return count    
}

export const copyStructureSelection = (gemmiStructure: gemmi.Structure, cidSelection?: string) => {
    const selection = new window.CCP4Module.Selection(cidSelection ? cidSelection : '/*/*/*')
    const newStruct = window.CCP4Module.remove_non_selected_atoms(gemmiStructure, selection)
    selection.delete()
    return newStruct
}

export const railSpecies = [
    'African Swamphen',
    'Allens Gallinule',
    'American Coot',
    'Andean Coot',
    'Australasian Swamphen',
    'Azure Gallinule',
    'Baillons Crake',
    'Band-bellied Crake',
    'Black Crake',
    'Black Rail',
    'Black-backed Moorhen',
    'Black-backed Swamphen',
    'Black-tailed Nativehen',
    'Black-tailed Waterhen',
    'Blackish Crake',
    'Blackish Rail',
    'Brown Crake',
    'Brown Swamphen',
    'Caribbean Coot',
    'Chatham Swamphen',
    'Chestnut Gallinule',
    'Chestnut-headed Crake',
    'Chiriqui Crake',
    'Common Gallinule',
    'Common Moorhen',
    'Common Waterhen',
    'Congo Moorhen',
    'Cuban Gallinule',
    'Egret',
    'Dusky Moorhen',
    'Eared Rail',
    'Eurasian Coot',
    'Eurasian Moorhen',
    'Fiji Rail',
    'Forest Crake',
    'Giant Coot',
    'Gough Moorhen',
    'Guam Rail',
    'Gray-headed Swamphen',
    'Great-crested Grebe',
    'Green-backed Gallinule',
    'Grey-headed Swamphen',
    'Hawaiian Gallinule',
    'Hawaiian Moorhen',
    'Henderson Crake',
    'Horned Coot',
    'King Rail',
    'Kosrae Crake',
    'Laysan Rail',
    'Least Moorhen',
    'Lesser Moorhen',
    'Little Crake',
    'Lord Howe Swamphen',
    'Makira Moorhen',
    'Makira Woodhen',
    'Maori Hen',
    'Mauritian Moorhen',
    'Micronesian Moorhen',
    'Moluccan Swamphen',
    'New Britain Swamphen',
    'North Island Takahe',
    'Pacific Swamphen',
    'Paint-billed Crake',
    'Palau Swamphen',
    'Papuan Swamphen',
    'Purple Gallinule',
    'Purple Swamphen',
    'Red Rail',
    'Red-fronted Coot',
    'Red-gartered Coot',
    'Red-knobbed Coot',
    'Red-legged Crake',
    'Reunion Ibis',
    'Roviana Rail',
    'Samoa Swamphen',
    'Samoan Moorhen',
    'Samoan Woodhen',
    'Slaty-breasted Rail',
    'Slaty-legged crake',
    'Sora',
    'Speckled Gallinule',
    'Spot-flanked gallinule',
    'Spotless Crake',
    'Tahiti Swamphen',
    'Takahe',
    'Talaud Rail',
    'Tasmanian Nativehen',
    'Tongan Moorhen',
    'Tristan Moorhen',
    'Triton Moorhen',
    'Vanuatu Swamphen',
    'Watercock',
    'Weka',
    'Western Swamphen',
    'White Gallinule',
    'White-breasted Waterhen',
    'White-browed Crake',
    'White-winged Coot',
    'Yellow Rail',
    'Yellow-breasted Crake'
]
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
